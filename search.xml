<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[test]]></title>
      <url>/2017/06/01/test/</url>
      <content type="html"><![CDATA[<p>tHub Wikis is a simple way to let others contribute content. Any GitHub user can create and edit pages to use for documentation, examples, support, or anything you wish.<br>Restrict editing to collaborators only<br>Public wikis will still be readable by everyone.<br>Issues<br>GitHub Issues adds lightweight issue tracking tightly integrated with your repository. Add issues to milestones, label issues, and close &amp; reference issues from commit messages.<br>Projects<br>Project boards on GitHub help you organize and prioritize your work. You can create project boards for specific feature work, comprehensive roadmaps, or even release checklists.<br>Merge button<br>When merging pull requests, you can allow any combination of merge commits, squashing, or rebasing. At least one option must be enabled.</p>
<p>Allow merge commits<br>Add all commits from the head branch to the base branch with a merge commit.<br>Allow squash merging<br>Combine all commits from the head branch into a single commit in the base branch.<br>Allow rebase merging<br>Add all commits from the head branch onto the base branch individually.<br>Temporary interaction limits<br>Temporarily restrict which users can interact with your repository (comment, open issues, or create pull requests) for a 24-hour period. This may be used to force a “cool-down” period during heated discussions.</p>
<p>Limit to existing users<br>Users that have recently created their account will be unable to interact with the repository.<br>Limit to prior contributors<br>Users that have not previously committed to the repository’s master branch will be unable to interact with the repository.<br>Limit to repository collaborators<br>Users that have not been granted push access will be unable to interact with the repository.<br>GitHub Pages<br>Your site is ready to be published at <a href="https://wfj0527.github.io/krystal.github.io/" target="_blank" rel="external">https://wfj0527.github.io/krystal.github.io/</a>.<br>GitHub Pages is designed to host your personal, organization, or project pages from a GitHub repository.</p>
<p>Source<br>Your GitHub Pages site is currently being built from the master branch. Learn more.<br> master branch   Save</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[面试总结]]></title>
      <url>/2017/04/18/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h2 id="你如何理解HTML结构的语意化"><a href="#你如何理解HTML结构的语意化" class="headerlink" title="你如何理解HTML结构的语意化?"></a>你如何理解HTML结构的语意化?</h2><ul>
<li>1、去掉或样式丢失的时候能让页面呈现清晰的结构。</li>
<li>2、屏幕阅读器（如果访客有视障）会完全根据你的标记来”读”你的网页。</li>
<li>3、PDA、手机等设备可能无法像普通电脑的浏览器一样来渲染网页（通常是因为这些设备对CSS的支持较弱）。</li>
<li>4、搜索引擎的爬虫也依赖于标记来确定上下文和各个关键字的权重。</li>
<li>5、你的页面是否对爬虫容易理解非常重要,因为爬虫很大程度上会忽略用于表现的标记，而只注重语义标记。</li>
<li>6、便于团队开发和维护。</li>
</ul>
<h2 id="我们知道可以以外链的方式引入CSS文件，请谈谈外链引入CSS有哪些方式，这些方式的性能有区别吗？"><a href="#我们知道可以以外链的方式引入CSS文件，请谈谈外链引入CSS有哪些方式，这些方式的性能有区别吗？" class="headerlink" title="我们知道可以以外链的方式引入CSS文件，请谈谈外链引入CSS有哪些方式，这些方式的性能有区别吗？"></a>我们知道可以以外链的方式引入CSS文件，请谈谈外链引入CSS有哪些方式，这些方式的性能有区别吗？</h2><p>CSS的引入方式最常用的有三种：</p>
<ul>
<li>第一：在head部分加入<code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;my.css&quot;/&gt;</code>, 引入外部的CSS文件。</li>
<li><p>第二：在head部分加入</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"> </span></div><div class="line">div&#123;margin: 0;padding: 0;border:1px red solid;&#125; </div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>第三:直接在页面的标签里加<code>&lt;div style=&quot;border:1px red solid;&quot;&gt;</code></p>
</li>
</ul>
<h2 id="行内元素有哪些？块级元素有哪些？"><a href="#行内元素有哪些？块级元素有哪些？" class="headerlink" title="行内元素有哪些？块级元素有哪些？"></a>行内元素有哪些？块级元素有哪些？</h2><ul>
<li>行内元素: a b span em img input select strong</li>
<li>块级元素：div ul li dl dt h1 h2 h3 p</li>
</ul>
<h2 id="前端网页由哪三层构成，分别是什么？作用是什么？"><a href="#前端网页由哪三层构成，分别是什么？作用是什么？" class="headerlink" title="前端网页由哪三层构成，分别是什么？作用是什么？"></a>前端网页由哪三层构成，分别是什么？作用是什么？</h2><p>网页分成三个层次，即：结构层、表示层、行为层。</p>
<ul>
<li>1、网页的结构层（structurallayer）由HTML 或XHTML 之类的标记语言负责创建。标签，也就是那些出现在尖括号里的单词，对网页内容的语义含义做出这些标签不包含任何关于如何显示有关内容的信息。例如，P标签表达了这样一种语义：”这是一个文本段。”</li>
<li>2、网页的表示层（presentationlayer）由CSS 负责创建。CSS对”如何显示有关内容”的问题做出了回答。</li>
<li>3、网页的行为层（behaviorlayer）负责回答”内容应该如何对事件做出反应”这一问题。这是Javascript 语言和DOM 主宰的领域</li>
</ul>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[聊一聊跨域]]></title>
      <url>/2017/04/09/%E8%B7%A8%E5%9F%9F/</url>
      <content type="html"><![CDATA[<h2 id="那些年，那些跨域"><a href="#那些年，那些跨域" class="headerlink" title="那些年，那些跨域"></a>那些年，那些跨域</h2><p>浏览器在请求不同域的资源时，会因为同源策略的影响请求不成功，这就是通常被提到的“跨域问题”。作为前端开发，解决跨域问题应该是一个被熟练掌握的技能。而随着技术不断的更迭，针对跨域问题的解决也衍生出了多种解决方案。我们通常会根据项目的不同需要，而采取不同的方式。这篇文章，将详细总结跨域问题的相关知识点，以便在遇到相同问题的时候，能有一个清晰的解决思路。</p>
<h2 id="跨域问题产生的背景"><a href="#跨域问题产生的背景" class="headerlink" title="跨域问题产生的背景"></a>跨域问题产生的背景</h2><p>早期为了防止CSRF（跨域请求伪造）的攻击，浏览器引入了同源策略(SOP)来提高安全性。</p>
<blockquote>
<p>CSRF（Cross-site request forgery），跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。</p>
</blockquote>
<p>而所谓”同源策略”，即同域名(domain或ip)、同端口、同协议的才能互相获取资源，而不能访问其他域的资源。在同源策略影响下，一个域名A的网页可以获取域名B下的脚本,css,图片等，但是不能发送Ajax请求，也不能操作Cookie、LocalStorage等数据。同源策略的存在，一方面提高了网站的安全性，但同时在面对前后端分离、模拟测试等场景时，也带来了一些麻烦，从而不得不寻求一些方法来突破限制，获取资源。</p>
<h2 id="JS跨域"><a href="#JS跨域" class="headerlink" title="JS跨域"></a>JS跨域</h2><p>这里所说的JS跨域，指的是在处理跨域请求的过程中，技术面会偏浏览器端较多一些，一般是利用浏览器的一些特性进行hack处理，从而避开同源策略的限制。</p>
<h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p>由于同源策略不会阻止动态脚本的插入到文档中去，所以催生出了一种很常用的跨域方式： JSONP(JSON with Padding)。</p>
<p>原理说起来也很简单：</p>
<p>假设，我们源页面是在a.com,想要获取b.com的数据，我们可以动态插入来源于b.com的脚本:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</div><div class="line">script.type = <span class="string">'text/javascript'</span>;</div><div class="line">script.src = <span class="string">'http://www.b.com/getdata?callback=demo'</span>;</div></pre></td></tr></table></figure>
<p>这里，我们利用动态脚本的src属性，变相地发送了一个<a href="http://www.b.com/getdata?callback=demo的GET" target="_blank" rel="external">http://www.b.com/getdata?callback=demo的GET</a>  请求。这时候，b.com页面接受到这个请求时，如果没有JSONP,会正常返回json的数据结果，像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="attr">msg</span>: <span class="string">'helloworld'</span> &#125;</div></pre></td></tr></table></figure>
<p>而利用JSONP,服务端会接受这个callback参数，然后用这个参数值包装要返回的数据：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">demo(&#123;<span class="attr">msg</span>: <span class="string">'helloworld'</span>&#125;);</div></pre></td></tr></table></figure>
<p>这时候，如果a.com的页面上正好有一个demo的函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(data.msg);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当远程数据一返回的时候，随着动态脚本的执行，这个demo函数就会被执行。</p>
<p>到这里，你应该能明白这个技术为什么叫JSONP了吧？就是因为使用这种技术服务器会接受回调函数名作为请求参数，并将JSON数据填充进回调函数中去。</p>
<p>不过一般在实际开发的时候，我们一般会利用jQuery对JSONP的支持，而避免手写很多代码。从1.2版本开始，jQuery中加入了对JSONP的支持，可以使用$.getJSON方法来请求跨域数据：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//callback后面的?会由jQuery自动生成方法名</span></div><div class="line">$.getJSON(<span class="string">'http://www.b.com/getdata?callback=?'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(data.msg);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>还有一种更加常用的方法是，利用$.ajax方法，只要指定dataType为jsonp即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$.ajax(&#123;</div><div class="line">  <span class="attr">url</span>: <span class="string">'http://www.b.com/getdata?callback=?'</span>, <span class="comment">//不指定回调名，可省略callback参数，会由jQuery自动生成</span></div><div class="line">  dataType: <span class="string">'jsonp'</span>,</div><div class="line">  <span class="attr">jsonpCallback</span>: <span class="string">'demo'</span>, <span class="comment">//可省略</span></div><div class="line">  success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(data.msg);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>虽然JSONP在跨域ajax请求方面有很强的能力，但是它也有一些缺陷。首先，它没有关于JSONP调用的错误处理，一旦回调函数调用失败，浏览器会以静默失败的方式处理。其次，它只支持GET请求，这是由于该技术本身的特性所决定的。因此，对于一些需要对安全性有要求的跨域请求，JSONP的使用需要谨慎一点了。</p>
<p>由于JSONP对于老浏览器兼容性方面比较良好，因此，对于那些对IE8以下仍然需要支持的网站来说，仍然被广泛应用。不过，针对高级浏览器，建议还是使用接下来会介绍的CORS方法。</p>
]]></content>
      
        
    </entry>
    
  
  
</search>
